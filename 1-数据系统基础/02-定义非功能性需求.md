# 简介

如果你正在构建一个应用程序，你将会被一系列需求所驱动。在你的需求列表中，最重要的可能是应用程序必须提供的功能：需要哪些界面和按钮，以及每个操作应该做什么，以实现软件的目的。这些是你的 ***功能性需求***。

此外，你可能还有一些 ***非功能性需求***：例如，应用程序应该快速、可靠、安全、合规，并且易于维护。这些需求可能没有明确写下来，但它们与应用程序的功能同样重要。

我们将考虑以下一些非功能性需求

- 如何定义和衡量系统的 **性能**
- 服务 **可靠** 意味着什么——即出现问题也能继续正确工作
- 通过在系统负载增长时添加计算能力的有效方法，使系统具有 **可伸缩性**
- 使系统长期更 **易于维护**



# 案例研究：社交网络首页时间线

你被赋予了实现一个类似 X（前身为 Twitter）风格的社交网络的任务，用户可以发布消息并关注其他用户。

假设用户每天发布 5 亿条帖子，或平均每秒 5,700 条帖子；偶尔速率可能飙升至每秒 150,000 条帖子。我们还假设平均每个用户关注 200 人并有 200 个粉丝；实际上大多数人只有少数粉丝，而少数名人如巴拉克・奥巴马有超过 1 亿粉丝。

## 表示用户、帖子与关注关系

假设我们将所有数据保存在关系数据库中，如 图 2-1 所示。我们有一个用户表、一个帖子表和一个关注关系表。

![img](02-定义非功能性需求.assets/ddia_0201.png)

<center style="color:#000;text-decoration:underline">图 2-1</center>



假设我们的社交网络必须支持的主要读取操作是 *首页时间线*，它显示你关注的人最近发布的帖子。我们可以编写以下 SQL 查询来获取特定用户的首页时间线：

```sql
SELECT posts.*, users.* FROM posts # 关注人的推文和个人信息
    JOIN follows ON posts.sender_id = follows.followee_id
    JOIN users ON posts.sender_id = users.id
    WHERE follows.follower_id = current_user # 查询当前用户关注了哪些人
    ORDER BY posts.timestamp DESC
    LIMIT 1000
```



假设在某人发布帖子后，我们希望他们的粉丝能够在 5 秒内看到它。一种方法是让用户的客户端每 5 秒重复上述查询（这称为 *轮询*）。如果我们假设有 1000 万用户同时在线登录，这意味着每秒运行 200 万次查询。即使增加轮询间隔，这也是很大的负载。

此外上述查询相当昂贵：如果你关注 200 人，它需要获取这 200 人中每个人的最近帖子列表，并合并这些列表。每秒 200 万次时间线查询意味着数据库需要每秒查找某个发送者的最近帖子 4 亿次。一些用户关注数万个账户；对他们来说，这个查询执行起来非常昂贵，而且很难快速完成。

## 时间线的物化与更新

首先，与其轮询，不如服务器主动向当前在线的任何粉丝推送新帖子。其次，我们应该预先计算上述查询的结果，以便可以从缓存中提供用户的首页时间线请求。



我们为每个用户存储一个包含其首页时间线的数据结构。每次用户发布帖子时，我们查找他们的所有粉丝，并将该帖子插入到每个粉丝的首页时间线中——就像向邮箱投递消息一样。

这种方法的缺点是，现在每次用户发布帖子时我们需要做更多的工作，因为首页时间线是需要更新的派生数据。该过程如 图 2-2 所示。当一个初始请求导致几个下游请求被执行时，我们使用术语 **扇出** 来描述请求数量增加的因子。

![img](02-定义非功能性需求.assets/ddia_0202.png)

<center style="color:#000;text-decoration:underline">图 2-2</center>

以每秒 5,700 条帖子的速率，如果平均帖子到达 200 个粉丝（即扇出因子为 200），我们将需要每秒执行超过 100 万次首页时间线写入。与我们本来需要的每秒 4 亿次每个发送者的帖子查找相比，这仍然是一个显著的节省。

如果由于某些特殊事件导致帖子速率激增，我们不必立即进行时间线交付——我们可以将它们**排队**，帖子在粉丝的时间线中显示会暂时花费更长时间。即使在这种负载峰值期间，时间线仍然可以快速加载，因为我们只是从缓存中提供它们。



这种预先计算和更新查询结果的过程称为 **物化**，时间线缓存是 **物化视图** 的一个例子。物化视图加速了读取，但作为交换，我们必须在写入时做更多的工作。

对于大多数用户来说，写入成本是适中的，但社交网络还必须考虑一些极端情况：

- 如果用户关注非常多的账户，并且这些账户发布很多内容，该用户的物化时间线将有很高的写入率。然而用户实际上不太可能阅读其时间线中的所有帖子，因此可以简单地丢弃其时间线的一些写入，只向用户显示他们关注的账户的**帖子样本**。
- 当拥有大量粉丝的名人账户发布帖子时，我们必须做大量工作将该帖子插入到他们数百万粉丝的每个首页时间线中。在这种情况下，丢弃一些写入是不可接受的。解决这个问题的一种方法是**将名人帖子与其他人的帖子分开处理**：我们可以通过将名人帖子单独存储并在读取时与物化时间线合并，来节省将它们添加到数百万时间线的工作。尽管有这些优化，处理社交网络上的名人仍然需要大量基础设施。



# 描述性能

